## main関数の引数とコマンドラインの引数

C++のmain関数は最大限に省略すれば、

```C++
int main(){}
```

となりますが、Cとも互換性のある次のような引数付きのmain関数


```C++
int main(int a, char** b){}
```

も使えます。

ここで、仮引数のシンボル名は特に意味はありませんのでとりあえず`a`、`b`としましたが、
Cの伝統から一般には`argc`、`argv`を名付けられている事も多いです。

このmain関数の引数にはOSからコマンドライン引数が渡されて実行されます。

例えば、先のコード例をコンパイルして`./a.out aaa bbb ccc`と実行したなら、
`a`には`4`、
`b`には`{"./a.out", "aaa", "bbb", "ccc"}`
という文字列のポインターへの配列が渡されます。

OSが渡してくれるコマンドライン引数は0番目が実行コマンド、
引数は1番目から入る仕様である事には少しばかり注意しましょう。

さて、せっかくなので内容を表示して見ましょう。

```C++
#include<iostream>
int main(int a, char** b)
{
  std::cout
    << a     << '\n'
    << &b    << '\n'
    << b     << '\t' << *b       << '\n'
    << b + 1 << '\t' << *(b + 1) << '\n'
    << b + 2 << '\t' << *(b + 2) << '\n'
    << b + 3 << '\t' << *(b + 3) << '\n'
    ;
}
```

`#include`はライブラリーを使う為のヘッダーファイルと呼ばれる
ソースコードファイルをこのプログラムのソースコードに取り込む指示をコンパイラーに与えています。

今回`"include`している`<iostream>`はC++が標準で備えるライブラリーの一部機能で入出力ストリームという機能を使う為に必要です。
`<iostream>`は標準入力や標準出力に対してストリームという形態で入出力を実現するC++で最も一般的な標準機能の1つです。

具体的な使い方とソースコードの解釈は後にして、
とりあえずは`./a.out aaa bbb ccc`と実行した結果を眺めてみましょう。

```bash
4
0x7ffffbcad7d8
0x7ffffbcad8f8  ./a.out
0x7ffffbcad900  aaa
0x7ffffbcad908  bbb
0x7ffffbcad910  ccc
```

`std::cout`は`<iostream>`により使用可能になる標準出力機能です。
これに`<<`二項演算子を使って出力したい「何か」を放り投げると、
標準出力にその「何か」をだいたいよしなに表示してくれます。

最初の行に`4`と出力されているのは、`a`にOSが渡してくれた「引数の数は全部で4つ」の値`4`です。

次の行では`b`のアドレスを`&`単行演算子で得て、その値を表示しています。

次の行では`b`を先ず出力しています。`b`は`char*`がどこにあるのかを示すポインター群の先頭の要素が格納されています。
なお、この値は通常、プログラムを実行する度に変化しますから、値が例と異なる結果を得ても驚く必要はありません。

続いて、`b`に格納されたメモリーアドレスを`*`単行演算子で関節参照し、格納されたメモリーアドレスに存在する`char*`型の値を取り出して`<<`により標準出力に渡しています。
`char*`は直接的に考えれば、どこかにある`char`のアドレスが格納された場所というだけの事ですが、
CやC++では`char`が連続で並んでいるメモリー上の領域を「文字列」として扱い、その最初の文字があるメモリー上の場所を`char*`型の値として扱う事で、文字列を扱います。

それで、ストリーム出力では`char**`型のbの0番目の要素としての`char*`を投げる事で、そのメモリーアドレスにある文字から始まるデータを文字列をとして扱い、実際に"aaa"と出力されました。

次の行では`b + 1`と`*(b + 1)`を出力しています。ポインターに対する`+`二項演算子は、1つめに与えられた左側の被演算子であるメモリーアドレスにしたいして、
その要素の型が占めるメモリーサイズ分×2つめに与えられた右側の被演算子の分だけメモリーアドレスを進めた結果を出力します。

`b`は`char**`型ですから、その要素の型は`char*`です。`char*`は一般に64bitシステムでは64bits、すなわち8bytes、32bitシステムでは32bits、すなわち4bytesです。
よって、この行の`b+1`は`b`の中身の要素で1つ先の隣のアドレスを示し、そこに記録された`char*`型のアドレス値を`*`単行演算子で関節参照して得た`char*`の値を文字列として表示しています。

言葉だけでは大変ややこしいと思います。簡単な図（もどき）を付けるので、
一般にC文字列と呼ばれる`char*`とその配列である`char**`とメモリーアドレスの状況について脳内でよく整理して理解して下さい。

```
シンボル         メモリーアドレス   型       格納されている値  解説
------------------------------------------------------------------------------------------------------------
<char*が連続した領域群: {0x7ffffbcad8f8, 0x7ffffbcad900, 0x7ffffbcad908, 0x7ffffbcad910}>
(b + 0)          [0x7ffffbcad7d8]   char*    0x7ffffbcad8f8    char*が連続した領域の0番目で、charが連続した領域0番目の先頭要素のアドレス
(b + 1)          [0x7ffffbcad7e8]   char*    0x7ffffbcad900    char*が連続した領域の1番目で、charが連続した領域の先頭要素のアドレス
(b + 2)          [0x7ffffbcad7f8]   char*    0x7ffffbcad908    char*が連続した領域の2番目で、charが連続した領域の先頭要素のアドレス
(b + 3)          [0x7ffffbcad808]   char*    0x7ffffbcad910    char*が連続した領域の3番目で、charが連続した領域の先頭要素のアドレス

<charが連続した領域群: 文字列 "./a.out">
(*(b + 0) + 0)   [0x7ffffbcad8f8]   char     .                 charが連続した領域0番目の0番目の要素
(*(b + 0) + 1)   [0x7ffffbcad8f9]   char     /                 charが連続した領域0番目の1番目の要素
(*(b + 0) + 2)   [0x7ffffbcad8fa]   char     a                 charが連続した領域0番目の2番目の要素
(*(b + 0) + 3)   [0x7ffffbcad8fb]   char     .                 charが連続した領域0番目の3番目の要素
(*(b + 0) + 4)   [0x7ffffbcad8fc]   char     o                 charが連続した領域0番目の4番目の要素
(*(b + 0) + 5)   [0x7ffffbcad8fd]   char     u                 charが連続した領域0番目の5番目の要素
(*(b + 0) + 6)   [0x7ffffbcad8fe]   char     t                 charが連続した領域0番目の6番目の要素

<charが連続した領域群: 文字列 "aaa">
(*(b + 1) + 0)   [0x7ffffbcad900]   char     a                 charが連続した領域1番目の0番目の要素
(*(b + 1) + 1)   [0x7ffffbcad901]   char     a                 charが連続した領域1番目の1番目の要素
(*(b + 1) + 2)   [0x7ffffbcad902]   char     a                 charが連続した領域1番目の2番目の要素

<charが連続した領域群: 文字列 "bbb">
(*(b + 2) + 0)   [0x7ffffbcad908]   char     b                 charが連続した領域2番目の0番目の要素
(*(b + 2) + 1)   [0x7ffffbcad909]   char     b                 charが連続した領域2番目の1番目の要素
(*(b + 2) + 2)   [0x7ffffbcad90a]   char     b                 charが連続した領域2番目の2番目の要素

<charが連続した領域群: 文字列 "ccc">
(*(b + 3) + 0)   [0x7ffffbcad910]   char     c                 charが連続した領域3番目の0番目の要素
(*(b + 3) + 1)   [0x7ffffbcad911]   char     c                 charが連続した領域3番目の1番目の要素
(*(b + 3) + 2)   [0x7ffffbcad912]   char     c                 charが連続した領域3番目の2番目の要素
```
